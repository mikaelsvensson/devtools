/*
 * Copyright 2014 Mikael Svensson
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package info.mikaelsvensson.devtools.analysis.db2eventlog;

import org.apache.commons.io.input.CountingInputStream;

import javax.xml.stream.XMLStreamException;
import java.io.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * Summarizes DB2 event log generated by the <tt>db2evmon</tt> utility.
 * <p/>
 * Example:
 * java info.mikaelsvensson.devtools.analysis.db2eventlog.Db2EventLogReport C:\TEMP\db2evmon-output.txt
 */
public class Db2EventLogReport {
    private static final int MILLION = 1000000;
    private static final String LINE_PREFIX_START_TIME = "  Start Time: ";
    private static final SimpleDateFormat TIME_FORMAT = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");
    //    private static final String LINE_PREFIX_INTERNAL_ROWS_INSERTED = "  Internal rows inserted: ";
//    private static final String LINE_PREFIX_INTERNAL_ROWS_UPDATED = "  Internal rows updated: ";
//    private static final String LINE_PREFIX_INTERNAL_ROWS_DELETED = "  Internal rows deleted: ";
    private static final String LINE_PREFIX_ROWS_WRITTEN = "  Rows written: ";
    private static final String LINE_PREFIX_ROWS_READ = "  Rows read: ";
    private static final String LINE_PREFIX_SORT_OVERFLOWS = "  Sort overflows: ";
    private static final String LINE_PREFIX_TOTAL_SORT_TIME = "  Total sort time: ";
    private static final String LINE_PREFIX_SORTS = "  Sorts: ";
    private static final String LINE_PREFIX_FETCH_COUNT = "  Fetch Count: ";
    private static final String LINE_PREFIX_ELAPSED_EXECUTION_TIME = "  Elapsed Execution Time:  ";
    private static final String LINE_PREFIX_TEXT = "  Text     : ";
    private static final String LINE_PREFIX_OPERATION = "  Operation: ";
    private Map<String, QueryStatistics> _records;
    private Date _startTime;
    private Date _stopTime;

    public Map<String, QueryStatistics> getRecords() {
        return _records;
    }

    static Db2EventLogReport fromLogFile(File logFile, String charsetName) throws IOException, XMLStreamException {
        return new Db2EventLogReport(logFile, charsetName);
    }

    private Db2EventLogReport(File logFile, String charsetName) throws IOException, XMLStreamException {
        load(logFile, charsetName);
    }

    private void load(File logFile, String charsetName) throws IOException, XMLStreamException {

        CountingInputStream is = new CountingInputStream(new FileInputStream(logFile));
        BufferedReader reader = new BufferedReader(new InputStreamReader(is, charsetName));

        String line = null;
        Db2EventLogSample currentSample = null;
        long fileSize = logFile.length();
        int percentDone = 0;

        _records = new HashMap<String, QueryStatistics>();
        while ((line = reader.readLine()) != null) {
            if (line.endsWith("Statement Event ...")) {
                int percentTemp = (int) (100.0 * is.getByteCount() / fileSize);
                if (percentDone != percentTemp) {
                    percentDone = percentTemp;
                    System.out.format("Progress: %d%%\r", percentDone);
                }
                handleSample(currentSample, _records);
                currentSample = new Db2EventLogSample(new Date(), 0);
            } else if (line.startsWith(LINE_PREFIX_OPERATION)) {
                currentSample.setOperation(line.substring(LINE_PREFIX_OPERATION.length()));
            } else if (line.startsWith(LINE_PREFIX_TEXT)) {
                currentSample.setText(line.substring(LINE_PREFIX_TEXT.length()));
            } else if (line.startsWith(LINE_PREFIX_START_TIME)) {
                try {
                    String timeString = line.substring(LINE_PREFIX_START_TIME.length(), LINE_PREFIX_START_TIME.length() + TIME_FORMAT.toPattern().length());
                    Date timeStamp = TIME_FORMAT.parse(timeString);
                    currentSample.setTimeStamp(timeStamp);
                } catch (ParseException e) {
                    e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
                }
            } else if (line.startsWith(LINE_PREFIX_ELAPSED_EXECUTION_TIME)) {
                String timeStr = line.substring(LINE_PREFIX_ELAPSED_EXECUTION_TIME.length());
                double time = Double.parseDouble(timeStr.substring(0, timeStr.indexOf(' ')));
                currentSample.setResponseTime((int) (time * MILLION));
            } else if (line.startsWith(LINE_PREFIX_FETCH_COUNT)) {
                long count = getLongAfterPrefix(line, LINE_PREFIX_FETCH_COUNT);
                currentSample.increaseFetchCount(count);
            } else if (line.startsWith(LINE_PREFIX_SORTS)) {
                long count = getLongAfterPrefix(line, LINE_PREFIX_SORTS);
                currentSample.increaseSorts(count);
            } else if (line.startsWith(LINE_PREFIX_TOTAL_SORT_TIME)) {
                long count = getLongAfterPrefix(line, LINE_PREFIX_TOTAL_SORT_TIME);
                currentSample.increaseTotalSortTime(count);
            } else if (line.startsWith(LINE_PREFIX_SORT_OVERFLOWS)) {
                long count = getLongAfterPrefix(line, LINE_PREFIX_SORT_OVERFLOWS);
                currentSample.increaseSortOverflows(count);
            } else if (line.startsWith(LINE_PREFIX_ROWS_READ)) {
                long count = getLongAfterPrefix(line, LINE_PREFIX_ROWS_READ);
                currentSample.increaseRowsRead(count);
            } else if (line.startsWith(LINE_PREFIX_ROWS_WRITTEN)) {
                long count = getLongAfterPrefix(line, LINE_PREFIX_ROWS_WRITTEN);
                currentSample.increaseRowsWritten(count);
            }
/*
            else if (line.startsWith(LINE_PREFIX_INTERNAL_ROWS_DELETED))
            {
                long count = getLongAfterPrefix(line, LINE_PREFIX_INTERNAL_ROWS_DELETED);
                currentSample.increaseInternalRowsDeleted(count);
            }
            else if (line.startsWith(LINE_PREFIX_INTERNAL_ROWS_UPDATED))
            {
                long count = getLongAfterPrefix(line, LINE_PREFIX_INTERNAL_ROWS_UPDATED);
                currentSample.increaseInternalRowsUpdated(count);
            }
            else if (line.startsWith(LINE_PREFIX_INTERNAL_ROWS_INSERTED))
            {
                long count = getLongAfterPrefix(line, LINE_PREFIX_INTERNAL_ROWS_INSERTED);
                currentSample.increaseInternalRowsInserted(count);
            }
*/
        }
        handleSample(currentSample, _records);
    }

    private long getLongAfterPrefix(String line, String prefix) {
        String countStr = line.substring(prefix.length());
        return Long.parseLong(countStr);
    }

    private void handleSample(Db2EventLogSample sample, Map<String, QueryStatistics> records) {
        if (sample != null) {
            if (_startTime == null) {
                _startTime = sample.getTimeStamp();
            }
            _stopTime = sample.getTimeStamp();
            if (sample.getText() == null || sample.getText().trim().length() == 0) {
                if ("Static Commit".equals(sample.getOperation())) {
                    sample.setText("**STATIC COMMIT**");
                } else if ("Static Rollback".equals(sample.getOperation())) {
                    sample.setText("**STATIC ROLLBACK**");
                } else if ("Set".equals(sample.getOperation())) {
                    sample.setText("**SET**");
                }
            }
            QueryStatistics queryStatistics = records.get(sample.getText());
            if (queryStatistics == null) {
                queryStatistics = new QueryStatistics(sample.getText(), records.size() + 1);
                records.put(sample.getText(), queryStatistics);
            }
            queryStatistics.addSampleData(sample);
        }
    }

    public Date getStopTime() {
        return _stopTime;
    }

    public Date getStartTime() {
        return _startTime;
    }

}
